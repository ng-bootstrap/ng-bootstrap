"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[429],{885:(or,dn,Zn)=>{Zn(8583);Error;const $o=function(s,...e){if($o.translate){const n=$o.translate(s,e);s=n[0],e=n[1]}let t=zl(s[0],s.raw[0]);for(let n=1;n<s.length;n++)t+=e[n-1]+zl(s[n],s.raw[n]);return t};function zl(s,e){return":"===e.charAt(0)?s.substring(function Ul(s,e){for(let t=1,n=1;t<s.length;t++,n++)if("\\"===e[n])n++;else if(":"===s[t])return t;throw new Error(`Unterminated $localize metadata block in "${e}".`)}(s,e)+1):s}(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)().$localize=$o},8583:()=>{!function(h){const v=h.performance;function S(oe){v&&v.mark&&v.mark(oe)}function g(oe,H){v&&v.measure&&v.measure(oe,H)}S("Zone");const _=h.__Zone_symbol_prefix||"__zone_symbol__";function I(oe){return _+oe}const N=!0===h[I("forceDuplicateZoneCheck")];if(h.Zone){if(N||"function"!=typeof h.Zone.__symbol__)throw new Error("Zone already loaded.");return h.Zone}let W=(()=>{class oe{constructor(d,y){this._parent=d,this._name=y?y.name||"unnamed":"<root>",this._properties=y&&y.properties||{},this._zoneDelegate=new U(this,this._parent&&this._parent._zoneDelegate,y)}static assertZonePatched(){if(h.Promise!==Be.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}static get root(){let d=oe.current;for(;d.parent;)d=d.parent;return d}static get current(){return ye.zone}static get currentTask(){return Me}static __load_patch(d,y,K=!1){if(Be.hasOwnProperty(d)){if(!K&&N)throw Error("Already loaded patch: "+d)}else if(!h["__Zone_disable_"+d]){const ne="Zone:"+d;S(ne),Be[d]=y(h,oe,ct),g(ne,ne)}}get parent(){return this._parent}get name(){return this._name}get(d){const y=this.getZoneWith(d);if(y)return y._properties[d]}getZoneWith(d){let y=this;for(;y;){if(y._properties.hasOwnProperty(d))return y;y=y._parent}return null}fork(d){if(!d)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,d)}wrap(d,y){if("function"!=typeof d)throw new Error("Expecting function got: "+d);const K=this._zoneDelegate.intercept(this,d,y),ne=this;return function(){return ne.runGuarded(K,this,arguments,y)}}run(d,y,K,ne){ye={parent:ye,zone:this};try{return this._zoneDelegate.invoke(this,d,y,K,ne)}finally{ye=ye.parent}}runGuarded(d,y=null,K,ne){ye={parent:ye,zone:this};try{try{return this._zoneDelegate.invoke(this,d,y,K,ne)}catch(qe){if(this._zoneDelegate.handleError(this,qe))throw qe}}finally{ye=ye.parent}}runTask(d,y,K){if(d.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(d.zone||Ce).name+"; Execution: "+this.name+")");if(d.state===we&&(d.type===te||d.type===pe))return;const ne=d.state!=ke;ne&&d._transitionTo(ke,q),d.runCount++;const qe=Me;Me=d,ye={parent:ye,zone:this};try{d.type==pe&&d.data&&!d.data.isPeriodic&&(d.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,d,y,K)}catch(D){if(this._zoneDelegate.handleError(this,D))throw D}}finally{d.state!==we&&d.state!==R&&(d.type==te||d.data&&d.data.isPeriodic?ne&&d._transitionTo(q,ke):(d.runCount=0,this._updateTaskCount(d,-1),ne&&d._transitionTo(we,ke,we))),ye=ye.parent,Me=qe}}scheduleTask(d){if(d.zone&&d.zone!==this){let K=this;for(;K;){if(K===d.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${d.zone.name}`);K=K.parent}}d._transitionTo(_e,we);const y=[];d._zoneDelegates=y,d._zone=this;try{d=this._zoneDelegate.scheduleTask(this,d)}catch(K){throw d._transitionTo(R,_e,we),this._zoneDelegate.handleError(this,K),K}return d._zoneDelegates===y&&this._updateTaskCount(d,1),d.state==_e&&d._transitionTo(q,_e),d}scheduleMicroTask(d,y,K,ne){return this.scheduleTask(new M(X,d,y,K,ne,void 0))}scheduleMacroTask(d,y,K,ne,qe){return this.scheduleTask(new M(pe,d,y,K,ne,qe))}scheduleEventTask(d,y,K,ne,qe){return this.scheduleTask(new M(te,d,y,K,ne,qe))}cancelTask(d){if(d.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(d.zone||Ce).name+"; Execution: "+this.name+")");d._transitionTo(de,q,ke);try{this._zoneDelegate.cancelTask(this,d)}catch(y){throw d._transitionTo(R,de),this._zoneDelegate.handleError(this,y),y}return this._updateTaskCount(d,-1),d._transitionTo(we,de),d.runCount=0,d}_updateTaskCount(d,y){const K=d._zoneDelegates;-1==y&&(d._zoneDelegates=null);for(let ne=0;ne<K.length;ne++)K[ne]._updateTaskCount(d.type,y)}}return oe.__symbol__=I,oe})();const Q={name:"",onHasTask:(oe,H,d,y)=>oe.hasTask(d,y),onScheduleTask:(oe,H,d,y)=>oe.scheduleTask(d,y),onInvokeTask:(oe,H,d,y,K,ne)=>oe.invokeTask(d,y,K,ne),onCancelTask:(oe,H,d,y)=>oe.cancelTask(d,y)};class U{constructor(H,d,y){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=H,this._parentDelegate=d,this._forkZS=y&&(y&&y.onFork?y:d._forkZS),this._forkDlgt=y&&(y.onFork?d:d._forkDlgt),this._forkCurrZone=y&&(y.onFork?this.zone:d._forkCurrZone),this._interceptZS=y&&(y.onIntercept?y:d._interceptZS),this._interceptDlgt=y&&(y.onIntercept?d:d._interceptDlgt),this._interceptCurrZone=y&&(y.onIntercept?this.zone:d._interceptCurrZone),this._invokeZS=y&&(y.onInvoke?y:d._invokeZS),this._invokeDlgt=y&&(y.onInvoke?d:d._invokeDlgt),this._invokeCurrZone=y&&(y.onInvoke?this.zone:d._invokeCurrZone),this._handleErrorZS=y&&(y.onHandleError?y:d._handleErrorZS),this._handleErrorDlgt=y&&(y.onHandleError?d:d._handleErrorDlgt),this._handleErrorCurrZone=y&&(y.onHandleError?this.zone:d._handleErrorCurrZone),this._scheduleTaskZS=y&&(y.onScheduleTask?y:d._scheduleTaskZS),this._scheduleTaskDlgt=y&&(y.onScheduleTask?d:d._scheduleTaskDlgt),this._scheduleTaskCurrZone=y&&(y.onScheduleTask?this.zone:d._scheduleTaskCurrZone),this._invokeTaskZS=y&&(y.onInvokeTask?y:d._invokeTaskZS),this._invokeTaskDlgt=y&&(y.onInvokeTask?d:d._invokeTaskDlgt),this._invokeTaskCurrZone=y&&(y.onInvokeTask?this.zone:d._invokeTaskCurrZone),this._cancelTaskZS=y&&(y.onCancelTask?y:d._cancelTaskZS),this._cancelTaskDlgt=y&&(y.onCancelTask?d:d._cancelTaskDlgt),this._cancelTaskCurrZone=y&&(y.onCancelTask?this.zone:d._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const K=y&&y.onHasTask;(K||d&&d._hasTaskZS)&&(this._hasTaskZS=K?y:Q,this._hasTaskDlgt=d,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=H,y.onScheduleTask||(this._scheduleTaskZS=Q,this._scheduleTaskDlgt=d,this._scheduleTaskCurrZone=this.zone),y.onInvokeTask||(this._invokeTaskZS=Q,this._invokeTaskDlgt=d,this._invokeTaskCurrZone=this.zone),y.onCancelTask||(this._cancelTaskZS=Q,this._cancelTaskDlgt=d,this._cancelTaskCurrZone=this.zone))}fork(H,d){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,H,d):new W(H,d)}intercept(H,d,y){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,H,d,y):d}invoke(H,d,y,K,ne){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,H,d,y,K,ne):d.apply(y,K)}handleError(H,d){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,H,d)}scheduleTask(H,d){let y=d;if(this._scheduleTaskZS)this._hasTaskZS&&y._zoneDelegates.push(this._hasTaskDlgtOwner),y=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,H,d),y||(y=d);else if(d.scheduleFn)d.scheduleFn(d);else{if(d.type!=X)throw new Error("Task is missing scheduleFn.");k(d)}return y}invokeTask(H,d,y,K){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,H,d,y,K):d.callback.apply(y,K)}cancelTask(H,d){let y;if(this._cancelTaskZS)y=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,H,d);else{if(!d.cancelFn)throw Error("Task is not cancelable");y=d.cancelFn(d)}return y}hasTask(H,d){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,H,d)}catch(y){this.handleError(H,y)}}_updateTaskCount(H,d){const y=this._taskCounts,K=y[H],ne=y[H]=K+d;if(ne<0)throw new Error("More tasks executed then were scheduled.");0!=K&&0!=ne||this.hasTask(this.zone,{microTask:y.microTask>0,macroTask:y.macroTask>0,eventTask:y.eventTask>0,change:H})}}class M{constructor(H,d,y,K,ne,qe){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=H,this.source=d,this.data=K,this.scheduleFn=ne,this.cancelFn=qe,!y)throw new Error("callback is not defined");this.callback=y;const D=this;this.invoke=H===te&&K&&K.useG?M.invokeTask:function(){return M.invokeTask.call(h,D,this,arguments)}}static invokeTask(H,d,y){H||(H=this),st++;try{return H.runCount++,H.zone.runTask(H,d,y)}finally{1==st&&T(),st--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(we,_e)}_transitionTo(H,d,y){if(this._state!==d&&this._state!==y)throw new Error(`${this.type} '${this.source}': can not transition to '${H}', expecting state '${d}'${y?" or '"+y+"'":""}, was '${this._state}'.`);this._state=H,H==we&&(this._zoneDelegates=null)}toString(){return this.data&&typeof this.data.handleId<"u"?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const le=I("setTimeout"),ce=I("Promise"),ie=I("then");let $,De=[],Te=!1;function k(oe){if(0===st&&0===De.length)if($||h[ce]&&($=h[ce].resolve(0)),$){let H=$[ie];H||(H=$.then),H.call($,T)}else h[le](T,0);oe&&De.push(oe)}function T(){if(!Te){for(Te=!0;De.length;){const oe=De;De=[];for(let H=0;H<oe.length;H++){const d=oe[H];try{d.zone.runTask(d,null,null)}catch(y){ct.onUnhandledError(y)}}}ct.microtaskDrainDone(),Te=!1}}const Ce={name:"NO ZONE"},we="notScheduled",_e="scheduling",q="scheduled",ke="running",de="canceling",R="unknown",X="microTask",pe="macroTask",te="eventTask",Be={},ct={symbol:I,currentZoneFrame:()=>ye,onUnhandledError:Ne,microtaskDrainDone:Ne,scheduleMicroTask:k,showUncaughtError:()=>!W[I("ignoreConsoleErrorUncaughtError")],patchEventTarget:()=>[],patchOnProperties:Ne,patchMethod:()=>Ne,bindArguments:()=>[],patchThen:()=>Ne,patchMacroTask:()=>Ne,patchEventPrototype:()=>Ne,isIEOrEdge:()=>!1,getGlobalObjects:()=>{},ObjectDefineProperty:()=>Ne,ObjectGetOwnPropertyDescriptor:()=>{},ObjectCreate:()=>{},ArraySlice:()=>[],patchClass:()=>Ne,wrapWithCurrentZone:()=>Ne,filterProperties:()=>[],attachOriginToPatched:()=>Ne,_redefineProperty:()=>Ne,patchCallbacks:()=>Ne};let ye={parent:null,zone:new W(null,null)},Me=null,st=0;function Ne(){}g("Zone","Zone"),h.Zone=W}(typeof window<"u"&&window||typeof self<"u"&&self||global);const dn=Object.getOwnPropertyDescriptor,Zn=Object.defineProperty,Xn=Object.getPrototypeOf,Ue=Object.create,gt=Array.prototype.slice,Pn="addEventListener",kn="removeEventListener",xs=Zone.__symbol__(Pn),Yn=Zone.__symbol__(kn),vt="true",Y="false",fn=Zone.__symbol__("");function mn(h,v){return Zone.current.wrap(h,v)}function Ln(h,v,S,g,_){return Zone.current.scheduleMacroTask(h,v,S,g,_)}const xe=Zone.__symbol__,Et=typeof window<"u",Lt=Et?window:void 0,je=Et&&Lt||"object"==typeof self&&self||global,oi=[null];function Fe(h,v){for(let S=h.length-1;S>=0;S--)"function"==typeof h[S]&&(h[S]=mn(h[S],v+"_"+S));return h}function Qn(h){return!h||!1!==h.writable&&!("function"==typeof h.get&&typeof h.set>"u")}const Jn=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,es=!("nw"in je)&&typeof je.process<"u"&&"[object process]"==={}.toString.call(je.process),ue=!es&&!Jn&&!(!Et||!Lt.HTMLElement),Qe=typeof je.process<"u"&&"[object process]"==={}.toString.call(je.process)&&!Jn&&!(!Et||!Lt.HTMLElement),ts={},ar=function(h){if(!(h=h||je.event))return;let v=ts[h.type];v||(v=ts[h.type]=xe("ON_PROPERTY"+h.type));const S=this||h.target||je,g=S[v];let _;if(ue&&S===Lt&&"error"===h.type){const I=h;_=g&&g.call(this,I.message,I.filename,I.lineno,I.colno,I.error),!0===_&&h.preventDefault()}else _=g&&g.apply(this,arguments),null!=_&&!_&&h.preventDefault();return _};function ur(h,v,S){let g=dn(h,v);if(!g&&S&&dn(S,v)&&(g={enumerable:!0,configurable:!0}),!g||!g.configurable)return;const _=xe("on"+v+"patched");if(h.hasOwnProperty(_)&&h[_])return;delete g.writable,delete g.value;const I=g.get,N=g.set,W=v.substr(2);let Q=ts[W];Q||(Q=ts[W]=xe("ON_PROPERTY"+W)),g.set=function(U){let M=this;!M&&h===je&&(M=je),M&&(M[Q]&&M.removeEventListener(W,ar),N&&N.apply(M,oi),"function"==typeof U?(M[Q]=U,M.addEventListener(W,ar,!1)):M[Q]=null)},g.get=function(){let U=this;if(!U&&h===je&&(U=je),!U)return null;const M=U[Q];if(M)return M;if(I){let le=I&&I.call(this);if(le)return g.set.call(this,le),"function"==typeof U.removeAttribute&&U.removeAttribute(v),le}return null},Zn(h,v,g),h[_]=!0}function Mn(h,v,S){if(v)for(let g=0;g<v.length;g++)ur(h,"on"+v[g],S);else{const g=[];for(const _ in h)"on"==_.substr(0,2)&&g.push(_);for(let _=0;_<g.length;_++)ur(h,g[_],S)}}const Tt=xe("originalInstance");function Rn(h){const v=je[h];if(!v)return;je[xe(h)]=v,je[h]=function(){const _=Fe(arguments,h);switch(_.length){case 0:this[Tt]=new v;break;case 1:this[Tt]=new v(_[0]);break;case 2:this[Tt]=new v(_[0],_[1]);break;case 3:this[Tt]=new v(_[0],_[1],_[2]);break;case 4:this[Tt]=new v(_[0],_[1],_[2],_[3]);break;default:throw new Error("Arg list too long.")}},Rt(je[h],v);const S=new v(function(){});let g;for(g in S)"XMLHttpRequest"===h&&"responseBlob"===g||function(_){"function"==typeof S[_]?je[h].prototype[_]=function(){return this[Tt][_].apply(this[Tt],arguments)}:Zn(je[h].prototype,_,{set:function(I){"function"==typeof I?(this[Tt][_]=mn(I,h+"."+_),Rt(this[Tt][_],I)):this[Tt][_]=I},get:function(){return this[Tt][_]}})}(g);for(g in v)"prototype"!==g&&v.hasOwnProperty(g)&&(je[h][g]=v[g])}function Mt(h,v,S){let g=h;for(;g&&!g.hasOwnProperty(v);)g=Xn(g);!g&&h[v]&&(g=h);const _=xe(v);let I=null;if(g&&(!(I=g[_])||!g.hasOwnProperty(_))&&(I=g[_]=g[v],Qn(g&&dn(g,v)))){const W=S(I,_,v);g[v]=function(){return W(this,arguments)},Rt(g[v],I)}return I}function ai(h,v,S){let g=null;function _(I){const N=I.data;return N.args[N.cbIdx]=function(){I.invoke.apply(this,arguments)},g.apply(N.target,N.args),I}g=Mt(h,v,I=>function(N,W){const Q=S(N,W);return Q.cbIdx>=0&&"function"==typeof W[Q.cbIdx]?Ln(Q.name,W[Q.cbIdx],Q,_):I.apply(N,W)})}function Rt(h,v){h[xe("OriginalDelegate")]=v}let Ts=!1,Cs=!1;function Vo(){if(Ts)return Cs;Ts=!0;try{const h=Lt.navigator.userAgent;(-1!==h.indexOf("MSIE ")||-1!==h.indexOf("Trident/")||-1!==h.indexOf("Edge/"))&&(Cs=!0)}catch{}return Cs}Zone.__load_patch("ZoneAwarePromise",(h,v,S)=>{const g=Object.getOwnPropertyDescriptor,_=Object.defineProperty,N=S.symbol,W=[],Q=!0===h[N("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],U=N("Promise"),M=N("then");S.onUnhandledError=D=>{if(S.showUncaughtError()){const x=D&&D.rejection;x?console.error("Unhandled Promise rejection:",x instanceof Error?x.message:x,"; Zone:",D.zone.name,"; Task:",D.task&&D.task.source,"; Value:",x,x instanceof Error?x.stack:void 0):console.error(D)}},S.microtaskDrainDone=()=>{for(;W.length;){const D=W.shift();try{D.zone.runGuarded(()=>{throw D.throwOriginal?D.rejection:D})}catch(x){ie(x)}}};const ce=N("unhandledPromiseRejectionHandler");function ie(D){S.onUnhandledError(D);try{const x=v[ce];"function"==typeof x&&x.call(this,D)}catch{}}function De(D){return D&&D.then}function Te(D){return D}function $(D){return d.reject(D)}const k=N("state"),T=N("value"),Ce=N("finally"),we=N("parentPromiseValue"),_e=N("parentPromiseState"),ke=null,R=!1;function pe(D,x){return b=>{try{ye(D,x,b)}catch(B){ye(D,!1,B)}}}const ct=N("currentTaskTrace");function ye(D,x,b){const B=function(){let D=!1;return function(b){return function(){D||(D=!0,b.apply(null,arguments))}}}();if(D===b)throw new TypeError("Promise resolved with itself");if(D[k]===ke){let ee=null;try{("object"==typeof b||"function"==typeof b)&&(ee=b&&b.then)}catch(se){return B(()=>{ye(D,!1,se)})(),D}if(x!==R&&b instanceof d&&b.hasOwnProperty(k)&&b.hasOwnProperty(T)&&b[k]!==ke)st(b),ye(D,b[k],b[T]);else if(x!==R&&"function"==typeof ee)try{ee.call(b,B(pe(D,x)),B(pe(D,!1)))}catch(se){B(()=>{ye(D,!1,se)})()}else{D[k]=x;const se=D[T];if(D[T]=b,D[Ce]===Ce&&!0===x&&(D[k]=D[_e],D[T]=D[we]),x===R&&b instanceof Error){const Z=v.currentTask&&v.currentTask.data&&v.currentTask.data.__creationTrace__;Z&&_(b,ct,{configurable:!0,enumerable:!1,writable:!0,value:Z})}for(let Z=0;Z<se.length;)Ne(D,se[Z++],se[Z++],se[Z++],se[Z++]);if(0==se.length&&x==R){D[k]=0;let Z=b;try{throw new Error("Uncaught (in promise): "+function I(D){return D&&D.toString===Object.prototype.toString?(D.constructor&&D.constructor.name||"")+": "+JSON.stringify(D):D?D.toString():Object.prototype.toString.call(D)}(b)+(b&&b.stack?"\n"+b.stack:""))}catch(J){Z=J}Q&&(Z.throwOriginal=!0),Z.rejection=b,Z.promise=D,Z.zone=v.current,Z.task=v.currentTask,W.push(Z),S.scheduleMicroTask()}}}return D}const Me=N("rejectionHandledHandler");function st(D){if(0===D[k]){try{const x=v[Me];x&&"function"==typeof x&&x.call(this,{rejection:D[T],promise:D})}catch{}D[k]=R;for(let x=0;x<W.length;x++)D===W[x].promise&&W.splice(x,1)}}function Ne(D,x,b,B,ee){st(D);const se=D[k],Z=se?"function"==typeof B?B:Te:"function"==typeof ee?ee:$;x.scheduleMicroTask("Promise.then",()=>{try{const J=D[T],G=!!b&&Ce===b[Ce];G&&(b[we]=J,b[_e]=se);const fe=x.run(Z,void 0,G&&Z!==$&&Z!==Te?[]:[J]);ye(b,!0,fe)}catch(J){ye(b,!1,J)}},b)}const H=function(){};class d{static toString(){return"function ZoneAwarePromise() { [native code] }"}static resolve(x){return ye(new this(null),!0,x)}static reject(x){return ye(new this(null),R,x)}static race(x){let b,B,ee=new this((J,G)=>{b=J,B=G});function se(J){b(J)}function Z(J){B(J)}for(let J of x)De(J)||(J=this.resolve(J)),J.then(se,Z);return ee}static all(x){return d.allWithCallback(x)}static allSettled(x){return(this&&this.prototype instanceof d?this:d).allWithCallback(x,{thenCallback:B=>({status:"fulfilled",value:B}),errorCallback:B=>({status:"rejected",reason:B})})}static allWithCallback(x,b){let B,ee,se=new this((fe,Ae)=>{B=fe,ee=Ae}),Z=2,J=0;const G=[];for(let fe of x){De(fe)||(fe=this.resolve(fe));const Ae=J;try{fe.then(re=>{G[Ae]=b?b.thenCallback(re):re,Z--,0===Z&&B(G)},re=>{b?(G[Ae]=b.errorCallback(re),Z--,0===Z&&B(G)):ee(re)})}catch(re){ee(re)}Z++,J++}return Z-=2,0===Z&&B(G),se}constructor(x){const b=this;if(!(b instanceof d))throw new Error("Must be an instanceof Promise.");b[k]=ke,b[T]=[];try{x&&x(pe(b,!0),pe(b,R))}catch(B){ye(b,!1,B)}}get[Symbol.toStringTag](){return"Promise"}get[Symbol.species](){return d}then(x,b){let B=this.constructor[Symbol.species];(!B||"function"!=typeof B)&&(B=this.constructor||d);const ee=new B(H),se=v.current;return this[k]==ke?this[T].push(se,ee,x,b):Ne(this,se,ee,x,b),ee}catch(x){return this.then(null,x)}finally(x){let b=this.constructor[Symbol.species];(!b||"function"!=typeof b)&&(b=d);const B=new b(H);B[Ce]=Ce;const ee=v.current;return this[k]==ke?this[T].push(ee,B,x,x):Ne(this,ee,B,x,x),B}}d.resolve=d.resolve,d.reject=d.reject,d.race=d.race,d.all=d.all;const y=h[U]=h.Promise;h.Promise=d;const K=N("thenPatched");function ne(D){const x=D.prototype,b=g(x,"then");if(b&&(!1===b.writable||!b.configurable))return;const B=x.then;x[M]=B,D.prototype.then=function(ee,se){return new d((J,G)=>{B.call(this,J,G)}).then(ee,se)},D[K]=!0}return S.patchThen=ne,y&&(ne(y),Mt(h,"fetch",D=>function qe(D){return function(x,b){let B=D.apply(x,b);if(B instanceof d)return B;let ee=B.constructor;return ee[K]||ne(ee),B}}(D))),Promise[v.__symbol__("uncaughtPromiseErrors")]=W,d}),Zone.__load_patch("toString",h=>{const v=Function.prototype.toString,S=xe("OriginalDelegate"),g=xe("Promise"),_=xe("Error"),I=function(){if("function"==typeof this){const U=this[S];if(U)return"function"==typeof U?v.call(U):Object.prototype.toString.call(U);if(this===Promise){const M=h[g];if(M)return v.call(M)}if(this===Error){const M=h[_];if(M)return v.call(M)}}return v.call(this)};I[S]=v,Function.prototype.toString=I;const N=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":N.call(this)}});let Ht=!1;if(typeof window<"u")try{const h=Object.defineProperty({},"passive",{get:function(){Ht=!0}});window.addEventListener("test",h,h),window.removeEventListener("test",h,h)}catch{Ht=!1}const lr={useG:!0},nt={},Kt={},cr=new RegExp("^"+fn+"(\\w+)(true|false)$"),As=xe("propagationStopped");function Zt(h,v){const S=(v?v(h):h)+Y,g=(v?v(h):h)+vt,_=fn+S,I=fn+g;nt[h]={},nt[h][Y]=_,nt[h][vt]=I}function pr(h,v,S){const g=S&&S.add||Pn,_=S&&S.rm||kn,I=S&&S.listeners||"eventListeners",N=S&&S.rmAll||"removeAllListeners",W=xe(g),Q="."+g+":",le=function($,k,T){if($.isRemoved)return;const Ce=$.callback;"object"==typeof Ce&&Ce.handleEvent&&($.callback=_e=>Ce.handleEvent(_e),$.originalDelegate=Ce),$.invoke($,k,[T]);const we=$.options;we&&"object"==typeof we&&we.once&&k[_].call(k,T.type,$.originalDelegate?$.originalDelegate:$.callback,we)},ce=function($){if(!($=$||h.event))return;const k=this||$.target||h,T=k[nt[$.type][Y]];if(T)if(1===T.length)le(T[0],k,$);else{const Ce=T.slice();for(let we=0;we<Ce.length&&(!$||!0!==$[As]);we++)le(Ce[we],k,$)}},ie=function($){if(!($=$||h.event))return;const k=this||$.target||h,T=k[nt[$.type][vt]];if(T)if(1===T.length)le(T[0],k,$);else{const Ce=T.slice();for(let we=0;we<Ce.length&&(!$||!0!==$[As]);we++)le(Ce[we],k,$)}};function De($,k){if(!$)return!1;let T=!0;k&&void 0!==k.useG&&(T=k.useG);const Ce=k&&k.vh;let we=!0;k&&void 0!==k.chkDup&&(we=k.chkDup);let _e=!1;k&&void 0!==k.rt&&(_e=k.rt);let q=$;for(;q&&!q.hasOwnProperty(g);)q=Xn(q);if(!q&&$[g]&&(q=$),!q||q[W])return!1;const ke=k&&k.eventNameToString,de={},R=q[W]=q[g],X=q[xe(_)]=q[_],pe=q[xe(I)]=q[I],te=q[xe(N)]=q[N];let Be;function ct(x,b){return!Ht&&"object"==typeof x&&x?!!x.capture:Ht&&b?"boolean"==typeof x?{capture:x,passive:!0}:x?"object"==typeof x&&!1!==x.passive?Object.assign(Object.assign({},x),{passive:!0}):x:{passive:!0}:x}k&&k.prepend&&(Be=q[xe(k.prepend)]=q[k.prepend]);const H=T?function(x){if(!de.isExisting)return R.call(de.target,de.eventName,de.capture?ie:ce,de.options)}:function(x){return R.call(de.target,de.eventName,x.invoke,de.options)},d=T?function(x){if(!x.isRemoved){const b=nt[x.eventName];let B;b&&(B=b[x.capture?vt:Y]);const ee=B&&x.target[B];if(ee)for(let se=0;se<ee.length;se++)if(ee[se]===x){ee.splice(se,1),x.isRemoved=!0,0===ee.length&&(x.allRemoved=!0,x.target[B]=null);break}}if(x.allRemoved)return X.call(x.target,x.eventName,x.capture?ie:ce,x.options)}:function(x){return X.call(x.target,x.eventName,x.invoke,x.options)},K=k&&k.diff?k.diff:function(x,b){const B=typeof b;return"function"===B&&x.callback===b||"object"===B&&x.originalDelegate===b},ne=Zone[xe("UNPATCHED_EVENTS")],qe=h[xe("PASSIVE_EVENTS")],D=function(x,b,B,ee,se=!1,Z=!1){return function(){const J=this||h;let G=arguments[0];k&&k.transferEventName&&(G=k.transferEventName(G));let fe=arguments[1];if(!fe)return x.apply(this,arguments);if(es&&"uncaughtException"===G)return x.apply(this,arguments);let Ae=!1;if("function"!=typeof fe){if(!fe.handleEvent)return x.apply(this,arguments);Ae=!0}if(Ce&&!Ce(x,fe,J,arguments))return;const re=Ht&&!!qe&&-1!==qe.indexOf(G),et=ct(arguments[2],re);if(ne)for(let At=0;At<ne.length;At++)if(G===ne[At])return re?x.call(J,G,fe,et):x.apply(this,arguments);const vn=!!et&&("boolean"==typeof et||et.capture),Xt=!(!et||"object"!=typeof et)&&et.once,Ns=Zone.current;let Yt=nt[G];Yt||(Zt(G,ke),Yt=nt[G]);const is=Yt[vn?vt:Y];let be,Bt=J[is],En=!1;if(Bt){if(En=!0,we)for(let At=0;At<Bt.length;At++)if(K(Bt[At],fe))return}else Bt=J[is]=[];const os=J.constructor.name,as=Kt[os];as&&(be=as[G]),be||(be=os+b+(ke?ke(G):G)),de.options=et,Xt&&(de.options.once=!1),de.target=J,de.capture=vn,de.eventName=G,de.isExisting=En;const Ct=T?lr:void 0;Ct&&(Ct.taskData=de);const Ze=Ns.scheduleEventTask(be,fe,Ct,B,ee);return de.target=null,Ct&&(Ct.taskData=null),Xt&&(et.once=!0),!Ht&&"boolean"==typeof Ze.options||(Ze.options=et),Ze.target=J,Ze.capture=vn,Ze.eventName=G,Ae&&(Ze.originalDelegate=fe),Z?Bt.unshift(Ze):Bt.push(Ze),se?J:void 0}};return q[g]=D(R,Q,H,d,_e),Be&&(q.prependListener=D(Be,".prependListener:",function(x){return Be.call(de.target,de.eventName,x.invoke,de.options)},d,_e,!0)),q[_]=function(){const x=this||h;let b=arguments[0];k&&k.transferEventName&&(b=k.transferEventName(b));const B=arguments[2],ee=!!B&&("boolean"==typeof B||B.capture),se=arguments[1];if(!se)return X.apply(this,arguments);if(Ce&&!Ce(X,se,x,arguments))return;const Z=nt[b];let J;Z&&(J=Z[ee?vt:Y]);const G=J&&x[J];if(G)for(let fe=0;fe<G.length;fe++){const Ae=G[fe];if(K(Ae,se))return G.splice(fe,1),Ae.isRemoved=!0,0===G.length&&(Ae.allRemoved=!0,x[J]=null,"string"==typeof b)&&(x[fn+"ON_PROPERTY"+b]=null),Ae.zone.cancelTask(Ae),_e?x:void 0}return X.apply(this,arguments)},q[I]=function(){const x=this||h;let b=arguments[0];k&&k.transferEventName&&(b=k.transferEventName(b));const B=[],ee=hr(x,ke?ke(b):b);for(let se=0;se<ee.length;se++){const Z=ee[se];B.push(Z.originalDelegate?Z.originalDelegate:Z.callback)}return B},q[N]=function(){const x=this||h;let b=arguments[0];if(b){k&&k.transferEventName&&(b=k.transferEventName(b));const B=nt[b];if(B){const Z=x[B[Y]],J=x[B[vt]];if(Z){const G=Z.slice();for(let fe=0;fe<G.length;fe++){const Ae=G[fe];this[_].call(this,b,Ae.originalDelegate?Ae.originalDelegate:Ae.callback,Ae.options)}}if(J){const G=J.slice();for(let fe=0;fe<G.length;fe++){const Ae=G[fe];this[_].call(this,b,Ae.originalDelegate?Ae.originalDelegate:Ae.callback,Ae.options)}}}}else{const B=Object.keys(x);for(let ee=0;ee<B.length;ee++){const Z=cr.exec(B[ee]);let J=Z&&Z[1];J&&"removeListener"!==J&&this[N].call(this,J)}this[N].call(this,"removeListener")}if(_e)return this},Rt(q[g],R),Rt(q[_],X),te&&Rt(q[N],te),pe&&Rt(q[I],pe),!0}let Te=[];for(let $=0;$<v.length;$++)Te[$]=De(v[$],S);return Te}function hr(h,v){if(!v){const I=[];for(let N in h){const W=cr.exec(N);let Q=W&&W[1];if(Q&&(!v||Q===v)){const U=h[N];if(U)for(let M=0;M<U.length;M++)I.push(U[M])}}return I}let S=nt[v];S||(Zt(v),S=nt[v]);const g=h[S[Y]],_=h[S[vt]];return g?_?g.concat(_):g.slice():_?_.slice():[]}function dr(h,v){const S=h.Event;S&&S.prototype&&v.patchMethod(S.prototype,"stopImmediatePropagation",g=>function(_,I){_[As]=!0,g&&g.apply(_,I)})}function fr(h,v,S,g,_){const I=Zone.__symbol__(g);if(v[I])return;const N=v[I]=v[g];v[g]=function(W,Q,U){return Q&&Q.prototype&&_.forEach(function(M){const le=`${S}.${g}::`+M,ce=Q.prototype;if(ce.hasOwnProperty(M)){const ie=h.ObjectGetOwnPropertyDescriptor(ce,M);ie&&ie.value?(ie.value=h.wrapWithCurrentZone(ie.value,le),h._redefineProperty(Q.prototype,M,ie)):ce[M]&&(ce[M]=h.wrapWithCurrentZone(ce[M],le))}else ce[M]&&(ce[M]=h.wrapWithCurrentZone(ce[M],le))}),N.call(v,W,Q,U)},h.attachOriginToPatched(v[g],N)}const ss=["absolutedeviceorientation","afterinput","afterprint","appinstalled","beforeinstallprompt","beforeprint","beforeunload","devicelight","devicemotion","deviceorientation","deviceorientationabsolute","deviceproximity","hashchange","languagechange","message","mozbeforepaint","offline","online","paint","pageshow","pagehide","popstate","rejectionhandled","storage","unhandledrejection","unload","userproximity","vrdisplayconnected","vrdisplaydisconnected","vrdisplaypresentchange"],li=["encrypted","waitingforkey","msneedkey","mozinterruptbegin","mozinterruptend"],Is=["load"],Ds=["blur","error","focus","load","resize","scroll","messageerror"],vr=["bounce","finish","start"],Ke=["loadstart","progress","abort","error","load","progress","timeout","loadend","readystatechange"],Ve=["upgradeneeded","complete","abort","success","error","blocked","versionchange","close"],Er=["close","error","open","message"],di=["error","message"],Le=["abort","animationcancel","animationend","animationiteration","auxclick","beforeinput","blur","cancel","canplay","canplaythrough","change","compositionstart","compositionupdate","compositionend","cuechange","click","close","contextmenu","curechange","dblclick","drag","dragend","dragenter","dragexit","dragleave","dragover","drop","durationchange","emptied","ended","error","focus","focusin","focusout","gotpointercapture","input","invalid","keydown","keypress","keyup","load","loadstart","loadeddata","loadedmetadata","lostpointercapture","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","mousewheel","orientationchange","pause","play","playing","pointercancel","pointerdown","pointerenter","pointerleave","pointerlockchange","mozpointerlockchange","webkitpointerlockerchange","pointerlockerror","mozpointerlockerror","webkitpointerlockerror","pointermove","pointout","pointerover","pointerup","progress","ratechange","reset","resize","scroll","seeked","seeking","select","selectionchange","selectstart","show","sort","stalled","submit","suspend","timeupdate","volumechange","touchcancel","touchmove","touchstart","touchend","transitioncancel","transitionend","waiting","wheel"].concat(["webglcontextrestored","webglcontextlost","webglcontextcreationerror"],["autocomplete","autocompleteerror"],["toggle"],["afterscriptexecute","beforescriptexecute","DOMContentLoaded","freeze","fullscreenchange","mozfullscreenchange","webkitfullscreenchange","msfullscreenchange","fullscreenerror","mozfullscreenerror","webkitfullscreenerror","msfullscreenerror","readystatechange","visibilitychange","resume"],ss,["beforecopy","beforecut","beforepaste","copy","cut","paste","dragstart","loadend","animationstart","search","transitionrun","transitionstart","webkitanimationend","webkitanimationiteration","webkitanimationstart","webkittransitionend"],["activate","afterupdate","ariarequest","beforeactivate","beforedeactivate","beforeeditfocus","beforeupdate","cellchange","controlselect","dataavailable","datasetchanged","datasetcomplete","errorupdate","filterchange","layoutcomplete","losecapture","move","moveend","movestart","propertychange","resizeend","resizestart","rowenter","rowexit","rowsdelete","rowsinserted","command","compassneedscalibration","deactivate","help","mscontentzoom","msmanipulationstatechanged","msgesturechange","msgesturedoubletap","msgestureend","msgesturehold","msgesturestart","msgesturetap","msgotpointercapture","msinertiastart","mslostpointercapture","mspointercancel","mspointerdown","mspointerenter","mspointerhover","mspointerleave","mspointermove","mspointerout","mspointerover","mspointerup","pointerout","mssitemodejumplistitemremoved","msthumbnailclick","stop","storagecommit"]);function rs(h,v,S){if(!S||0===S.length)return v;const g=S.filter(I=>I.target===h);if(!g||0===g.length)return v;const _=g[0].ignoreProperties;return v.filter(I=>-1===_.indexOf(I))}function Oe(h,v,S,g){h&&Mn(h,rs(h,v,S),g)}Zone.__load_patch("util",(h,v,S)=>{S.patchOnProperties=Mn,S.patchMethod=Mt,S.bindArguments=Fe,S.patchMacroTask=ai;const g=v.__symbol__("BLACK_LISTED_EVENTS"),_=v.__symbol__("UNPATCHED_EVENTS");h[_]&&(h[g]=h[_]),h[g]&&(v[g]=v[_]=h[g]),S.patchEventPrototype=dr,S.patchEventTarget=pr,S.isIEOrEdge=Vo,S.ObjectDefineProperty=Zn,S.ObjectGetOwnPropertyDescriptor=dn,S.ObjectCreate=Ue,S.ArraySlice=gt,S.patchClass=Rn,S.wrapWithCurrentZone=mn,S.filterProperties=rs,S.attachOriginToPatched=Rt,S._redefineProperty=Object.defineProperty,S.patchCallbacks=fr,S.getGlobalObjects=()=>({globalSources:Kt,zoneSymbolEventNames:nt,eventNames:Le,isBrowser:ue,isMix:Qe,isNode:es,TRUE_STR:vt,FALSE_STR:Y,ZONE_SYMBOL_PREFIX:fn,ADD_EVENT_LISTENER_STR:Pn,REMOVE_EVENT_LISTENER_STR:kn})});const gn=xe("zoneTask");function lt(h,v,S,g){let _=null,I=null;S+=g;const N={};function W(U){const M=U.data;return M.args[0]=function(){return U.invoke.apply(this,arguments)},M.handleId=_.apply(h,M.args),U}function Q(U){return I.call(h,U.data.handleId)}_=Mt(h,v+=g,U=>function(M,le){if("function"==typeof le[0]){const ce={isPeriodic:"Interval"===g,delay:"Timeout"===g||"Interval"===g?le[1]||0:void 0,args:le},ie=le[0];le[0]=function(){try{return ie.apply(this,arguments)}finally{ce.isPeriodic||("number"==typeof ce.handleId?delete N[ce.handleId]:ce.handleId&&(ce.handleId[gn]=null))}};const De=Ln(v,le[0],ce,W,Q);if(!De)return De;const Te=De.data.handleId;return"number"==typeof Te?N[Te]=De:Te&&(Te[gn]=De),Te&&Te.ref&&Te.unref&&"function"==typeof Te.ref&&"function"==typeof Te.unref&&(De.ref=Te.ref.bind(Te),De.unref=Te.unref.bind(Te)),"number"==typeof Te||Te?Te:De}return U.apply(h,le)}),I=Mt(h,S,U=>function(M,le){const ce=le[0];let ie;"number"==typeof ce?ie=N[ce]:(ie=ce&&ce[gn],ie||(ie=ce)),ie&&"string"==typeof ie.type?"notScheduled"!==ie.state&&(ie.cancelFn&&ie.data.isPeriodic||0===ie.runCount)&&("number"==typeof ce?delete N[ce]:ce&&(ce[gn]=null),ie.zone.cancelTask(ie)):U.apply(h,le)})}Zone.__load_patch("legacy",h=>{const v=h[Zone.__symbol__("legacyPatch")];v&&v()}),Zone.__load_patch("queueMicrotask",(h,v,S)=>{S.patchMethod(h,"queueMicrotask",g=>function(_,I){v.current.scheduleMicroTask("queueMicrotask",I[0])})}),Zone.__load_patch("timers",h=>{const v="set",S="clear";lt(h,v,S,"Timeout"),lt(h,v,S,"Interval"),lt(h,v,S,"Immediate")}),Zone.__load_patch("requestAnimationFrame",h=>{lt(h,"request","cancel","AnimationFrame"),lt(h,"mozRequest","mozCancel","AnimationFrame"),lt(h,"webkitRequest","webkitCancel","AnimationFrame")}),Zone.__load_patch("blocking",(h,v)=>{const S=["alert","prompt","confirm"];for(let g=0;g<S.length;g++)Mt(h,S[g],(I,N,W)=>function(Q,U){return v.current.run(I,h,U,W)})}),Zone.__load_patch("EventTarget",(h,v,S)=>{(function vi(h,v){v.patchEventPrototype(h,v)})(h,S),function gi(h,v){if(Zone[v.symbol("patchEventTarget")])return;const{eventNames:S,zoneSymbolEventNames:g,TRUE_STR:_,FALSE_STR:I,ZONE_SYMBOL_PREFIX:N}=v.getGlobalObjects();for(let Q=0;Q<S.length;Q++){const U=S[Q],ce=N+(U+I),ie=N+(U+_);g[U]={},g[U][I]=ce,g[U][_]=ie}const W=h.EventTarget;W&&W.prototype&&v.patchEventTarget(h,[W&&W.prototype])}(h,S);const g=h.XMLHttpRequestEventTarget;g&&g.prototype&&S.patchEventTarget(h,[g.prototype])}),Zone.__load_patch("MutationObserver",(h,v,S)=>{Rn("MutationObserver"),Rn("WebKitMutationObserver")}),Zone.__load_patch("IntersectionObserver",(h,v,S)=>{Rn("IntersectionObserver")}),Zone.__load_patch("FileReader",(h,v,S)=>{Rn("FileReader")}),Zone.__load_patch("on_property",(h,v,S)=>{!function fi(h,v){if(es&&!Qe||Zone[h.symbol("patchEvents")])return;const S=typeof WebSocket<"u",g=v.__Zone_ignore_on_properties;if(ue){const N=window,W=function ns(){try{const h=Lt.navigator.userAgent;if(-1!==h.indexOf("MSIE ")||-1!==h.indexOf("Trident/"))return!0}catch{}return!1}()?[{target:N,ignoreProperties:["error"]}]:[];Oe(N,Le.concat(["messageerror"]),g&&g.concat(W),Xn(N)),Oe(Document.prototype,Le,g),typeof N.SVGElement<"u"&&Oe(N.SVGElement.prototype,Le,g),Oe(Element.prototype,Le,g),Oe(HTMLElement.prototype,Le,g),Oe(HTMLMediaElement.prototype,li,g),Oe(HTMLFrameSetElement.prototype,ss.concat(Ds),g),Oe(HTMLBodyElement.prototype,ss.concat(Ds),g),Oe(HTMLFrameElement.prototype,Is,g),Oe(HTMLIFrameElement.prototype,Is,g);const Q=N.HTMLMarqueeElement;Q&&Oe(Q.prototype,vr,g);const U=N.Worker;U&&Oe(U.prototype,di,g)}const _=v.XMLHttpRequest;_&&Oe(_.prototype,Ke,g);const I=v.XMLHttpRequestEventTarget;I&&Oe(I&&I.prototype,Ke,g),typeof IDBIndex<"u"&&(Oe(IDBIndex.prototype,Ve,g),Oe(IDBRequest.prototype,Ve,g),Oe(IDBOpenDBRequest.prototype,Ve,g),Oe(IDBDatabase.prototype,Ve,g),Oe(IDBTransaction.prototype,Ve,g),Oe(IDBCursor.prototype,Ve,g)),S&&Oe(WebSocket.prototype,Er,g)}(S,h)}),Zone.__load_patch("customElements",(h,v,S)=>{!function mi(h,v){const{isBrowser:S,isMix:g}=v.getGlobalObjects();(S||g)&&h.customElements&&"customElements"in h&&v.patchCallbacks(v,h.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback"])}(h,S)}),Zone.__load_patch("XHR",(h,v)=>{!function Q(U){const M=U.XMLHttpRequest;if(!M)return;const le=M.prototype;let ie=le[xs],De=le[Yn];if(!ie){const X=U.XMLHttpRequestEventTarget;if(X){const pe=X.prototype;ie=pe[xs],De=pe[Yn]}}const Te="readystatechange",$="scheduled";function k(X){const pe=X.data,te=pe.target;te[I]=!1,te[W]=!1;const Be=te[_];ie||(ie=te[xs],De=te[Yn]),Be&&De.call(te,Te,Be);const ct=te[_]=()=>{if(te.readyState===te.DONE)if(!pe.aborted&&te[I]&&X.state===$){const Me=te[v.__symbol__("loadfalse")];if(0!==te.status&&Me&&Me.length>0){const st=X.invoke;X.invoke=function(){const Ne=te[v.__symbol__("loadfalse")];for(let oe=0;oe<Ne.length;oe++)Ne[oe]===X&&Ne.splice(oe,1);!pe.aborted&&X.state===$&&st.call(X)},Me.push(X)}else X.invoke()}else!pe.aborted&&!1===te[I]&&(te[W]=!0)};return ie.call(te,Te,ct),te[S]||(te[S]=X),de.apply(te,pe.args),te[I]=!0,X}function T(){}function Ce(X){const pe=X.data;return pe.aborted=!0,R.apply(pe.target,pe.args)}const we=Mt(le,"open",()=>function(X,pe){return X[g]=0==pe[2],X[N]=pe[1],we.apply(X,pe)}),q=xe("fetchTaskAborting"),ke=xe("fetchTaskScheduling"),de=Mt(le,"send",()=>function(X,pe){if(!0===v.current[ke]||X[g])return de.apply(X,pe);{const te={target:X,url:X[N],isPeriodic:!1,args:pe,aborted:!1},Be=Ln("XMLHttpRequest.send",T,te,k,Ce);X&&!0===X[W]&&!te.aborted&&Be.state===$&&Be.invoke()}}),R=Mt(le,"abort",()=>function(X,pe){const te=function ce(X){return X[S]}(X);if(te&&"string"==typeof te.type){if(null==te.cancelFn||te.data&&te.data.aborted)return;te.zone.cancelTask(te)}else if(!0===v.current[q])return R.apply(X,pe)})}(h);const S=xe("xhrTask"),g=xe("xhrSync"),_=xe("xhrListener"),I=xe("xhrScheduled"),N=xe("xhrURL"),W=xe("xhrErrorBeforeScheduled")}),Zone.__load_patch("geolocation",h=>{h.navigator&&h.navigator.geolocation&&function yt(h,v){const S=h.constructor.name;for(let g=0;g<v.length;g++){const _=v[g],I=h[_];if(I){if(!Qn(dn(h,_)))continue;h[_]=(W=>{const Q=function(){return W.apply(this,Fe(arguments,S+"."+_))};return Rt(Q,W),Q})(I)}}}(h.navigator.geolocation,["getCurrentPosition","watchPosition"])}),Zone.__load_patch("PromiseRejectionEvent",(h,v)=>{function S(g){return function(_){hr(h,g).forEach(N=>{const W=h.PromiseRejectionEvent;if(W){const Q=new W(g,{promise:_.promise,reason:_.rejection});N.invoke(Q)}})}}h.PromiseRejectionEvent&&(v[xe("unhandledPromiseRejectionHandler")]=S("unhandledrejection"),v[xe("rejectionHandledHandler")]=S("rejectionhandled"))})}},or=>{or(or.s=885)}]);